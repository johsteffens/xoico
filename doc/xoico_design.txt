Author and Copyright 2020 Johannes Bernhard Steffens

XOICO Framework Design

Xoila is a mostly declarative language that can be immersed with
c-code.

It was initially invented for the beth framework and originally called "beth_plant".
The term plant reflects the notion of 'planting' (embedding) dedicated code with regular
source code.

A xoila compiler translates xoila code into c-source code.
XOI code is located in C-header files.
Translated c-source code is written into dedicated files, which can be
included and compiled with other c-source code.

Copyright and License of generated code:
  Code generated by the xoila compiler inherits the copyright and license of the xoila
  source code. This information should have been placed inside the header file containing xoila
  source code. Generated files contain a list of source files used.

Usage:
XOILA_DEFINE_GROUP( <group_name>, <trait_name> )
#ifdef XOILA_SECTION
    signature <ret> <func_name>( {plain | const | mutable}, <args> );
           plain: plain function (no object pointer as first argument)
           const:   const member function;   first argument: const @* o
           mutable: mutable member function; first argument:       @* o

    signature extending <signature> <func_name>[( <additional-args> )];

    feature [strict] ['<flags>'] <syntax-of-signature> [ = <body> ];

    func feature : name [= { <body> }];

    stamp <name> = [aware] <trait> { reflection-body };
    stamp <name> = extending <tmpl> { reflection-body-extension }; // uses 'tmpl' as template to be extended; 'tmpl' can be a stamp or stump.
    stump ... // same as stamp definition. A 'stump' is not expanded into code. But it can be used as template. Stump-functions are overloadable.
    {stamp|stump} verbatim ....  // keyword 'verbatim' disables all automatic extensions for this definition

    // automatic extending
    extending <name>;    // stamp 'name' will be extended in all subsequent stamps that do not explicitly use 'extending'
    extending stump ...; // extends this stump definition
    extending;           // turns automatic extending off

    name <name>;
    type <name>;

    group <name> = [<trait>] { ... }; // sub-group; inheriting from parent: 'extending', 'func'

    embed "<include file path>";

    ...
#endif // <xoila-closer>

xoila-opener:
  c-style comment-opener or '#ifdef XOILA_SECTION'
  Macro XOILA_SECTION must never be defined.

xoila-closer:
  c-style comment-closer or '#endif' (depending on what was used for xoila-opener)

----------------------------------------------------------------------------------------------
body:
  A body consists of C-code and specific xoila controls.

  body <name> = <body-expression>; // definition of a body

  <body-expression>:
     { code.... } [: <body-expression>];
     <body-name>  [: <body-expression>];

  inside body code:
     \body <body-expression>; // expands another body
     :<alphabetic-character>  // expands namespace
     :<space>                 // expands to ':<space>' (without evaluation)
     \:                       // expands to ':' (without evaluation)

----------------------------------------------------------------------------------------------
feature:
  The feature definition triggers implicit definition of a perspective <group_name>
  and corresponding inline implementations for each (virtual) function 'func_name'.
  <flags>-setting (s.below) determines which referencing method is offered for the feature.

     Calling a feature depending on referencing method.
     Note:
       Calling an unbound function can result in a segmentation fault.
       Use check below to probe for a valid binding.
     <ret> <group_name>_p_<func_name>( const <group_name>_s* p, <args> );
     <ret> <group_name>_t_<func_name>( tp_t __t, [const] <group_name>* o, <args> );
     <ret> <group_name>_a_<func_name>( [const] <group_name>* o, <args> );
     <ret> <group_name>_r_<func_name>( const sr_s* o, <args> );

     Checks whether binding exists for given object.
     Existing <default_func> qualifies as valid binding for all objects.
     bl_t <group_name>_p_defines_<func_name>( const <group_name>_s* p );
     bl_t <group_name>_t_defines_<func_name>( tp_t t );
     bl_t <group_name>_a_defines_<func_name>( const <group_name>* o );
     bl_t <group_name>_r_defines_<func_name>( const sr_s* o );

  flags:
      Any character sub-list of 'ptar' specifying which type of virtual function shall
      be inline implemented. If no list is specified, 'a' is assumed.

  strict:
      Any object referenced by the perspective must define the function.

  default_name:
      Optional default function used when the object does not define the feature.
      Requires implementing <ret> <group_name>_<default_name>( [const] <group_name>* o, <args> );

----------------------------------------------------------------------------------------------
func:
  Generic default function definition that is automatically applied to all stamps in this group.
  A stamp can overload this definition by defining func of the same name.
  In a group a function can be redefined under the same name.

----------------------------------------------------------------------------------------------
name:
  Identifier definition. Generates tp_t TYPEOF_<name>. Registers <name> in name manager.
  <name> has global scope. Multiple definitions of the same name at different places are allowed.

----------------------------------------------------------------------------------------------
type:
  Like 'name' with additional type-registration at compiler level.
  This is used to tell the compiler about external types and traits. e.g. st_s, bcore_source, ...

----------------------------------------------------------------------------------------------
forward:
  Forward declaration. Generates tp_t TYPEOF_<name> and BCORE_FORWARD_OBJECT( <name> );
  <name> has global scope. Multiple definitions of the same forwarding at different places are allowed.

----------------------------------------------------------------------------------------------
stamp:

  Reflection of object definition for objects (see flect.h for general syntax)
  Function definitions in reflections are matched and bound to features or signatures.
  C-Prototypes are generated and registered as featured function.

  Function Syntax:
   func <group_name> . <signature_name> [ = { <body> }];
         <signature_name> is a signature defined in group <group_name>
         Creates a function <stamp_name>_s_<signature_name>.

   func <group_name> . <feature_name> [ = { <body> }];
         <feature_name> is a feature defined in group <group_name>
         Creates a function <stamp_name>_s_<feature_name> and binds it to <group_name>_<feature_name>.

   func (<signature-def>) [ = { <body> }];
         Creates a function <stamp_name>_s_<signature_name>.

  Special conditions:
    ':' following stamp means that '<group_name>_' is prefixed to the following name
    ':' instead of trait means that '<group_name>' is declared as trait
    ':' (no func) preceding an identifier name means that '<group_name>_' is prefixed to the following name
    ':' (in func) if no perspective name precedes ':' then <group_name> is used as perspective
   'func ^ : <func_name>'  <trait_name> is used as perspective

  Special characters:
    Special characters are evaluated and replaced with specific text
    for signature types and body code. Signature and body definition
    can be outside the stamp. Replacement happens in all stamps to which
    they are assigned.

    '@' : is replaced by the stamp's type name if expansion happens in a stamp.
        Otherwise it is replaced by the groups type name.
          Example: In stamp 'foo_s'
             @ is replaced by "foo_s"

  Special traits:
    bcore_array: expands additional array-functions
      void set_space( o, size ) // preallocation
      void set_size(  o, size ) // preallocation + size specification
      void clear(     o,      ) // clears array (sets space to 0)
      void push_c(    o, v    ) // pushes element by copying it
      void push_d(    o, v    ) // pushes element by passing ownership  (whether element is copied depends on array-type)

Functions:
  Features and functions inside a stamp can have a body.
  The body is enclosed in '{ ... }' and contains ordinary c-code.
  Exceptions:
    Symbol ':' immediately followed by a name serves as namespace expander

----------------------------------------------------------------------------------------------

set:
  Keyword 'set' defines certain group-specific flags:
    enroll: This flag forces all stamps in the group to be fully enrolled.
            This requires extra memory and is normally not recommended.
            It is useful when objects are intended to be always reverse-traceable by trait.

----------------------------------------------------------------------------------------------

embed:
  Embeds the content of a file into the section.
  A relative path is considered relative to the given file location

----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------

cdaleth syntax:

The cdaleth syntax is 'C' with additional syntactic rules.
Pure C-code can be enforced for any code block with this
syntax '{\C ... }'.

':' immediately before an identifier or '*' will replace ':' with the group name
'@' will be replaced with stamp instance name if applicable or with group name otherwise

typespec tracing:
The typespec is traced inside an expression whenever possible.

Where a typespec can be traced:
    '.' can be used as member access even when the variable is a pointer.
    Member functions can be called as element functions.

Casting:
    'cast( <typespec>, <expression> )'
translates to
   '( ( <typespec> )  ( <expression> ) )'
or
   '( ( <typespec> ) &( <expression> ) )'
in case <typespec>'s indirection is one above <expression>.

Arrays:
'<expr1>.[ <expr1> ]' translates to '<expr1>.data[ <expr1> ]'
If <expr1> represents a stamp with an anonymous array element.

Automatic variable definition:
 '<name> := <expression>' translates to <typespec> '<name> = <expression>'
 with <typespec> being the typespec of <expression>

Function pointer:
If an object-element is a function pointer, calling that function must be enclosed
in '{\C ... }'.

TODO:
- (done) each group has a perspective
- (done) each group has default (aware, typed) features: *_t_create, _a_discard, _a_attach, _a_detach, _a_copy, _t_clone
- (done) add inexpandable features for above functions
- (done) rename default bodies of features from *__ to *_default.  (the default name can also be manually set)
- (done) new operator '=<' corresponds to function attach; expr =< NULL corresponds to detach;
- (done) attach on groups: check for type consistency
- (done) positfix operator '!' after a type converts it into a traced <type>_create(); (no effect if lvalue has indirection 0)
- (done) positfix operator '?.' after a type checks if lvalue is zero before dereferencing (no effect if lvalue has indirection 0)
- (done) provide foreach - loop
- (pending) bounds check '?[<index>]' checks if index is out of range
- (done) do not adapt indirection of void pointer types vc_t, vd_t
- (done) introduce verbatim_C{ .... } where code inside {} is taken as literal C code.
- (done) replace {\C .... } with {verbatim_C{ .... }}
- (done) add type specifier 'keep' (e.g. to be used in function returns) telling the compiler to take control of the object's lifetime
- (done) add lifetime management for return and break statements
- (done) isolate trans_declaration: processes declaration (with assignment) in case a declaration is intended, otherwise does nothing.
- (done) move trans_declaration from trans_expression to trans_statement and trans_for
- auto-keep function return values marked 'keep'
- auto-try functions when value is marked 'try'
- (done) add 'fork' a functional keyword representing a type-reserving bcore_fork.
- (done) add 'keep_func', 'keep_block'
- redefine keep: scope( expr [, var] ), which keeps the result of expression in the scope of var. Without 'var', the scope is the current block.
- define plain functions in a group
- cengie: recognize a full function name (non-member)
- implement try-expression
- (done) allow signature definition along with function declaration
- (done) allow stamp member function declaration outside stamp
- (done) allow signature definition inside a function declaration
- remove redundant 'plain' specifier in plain-functions
- (done) replace function name delimiter ':' with '.'
- (done) bracket-expressions '(....)' should yield typespec where possible
- (fixed) bug: too many closing ')' stalls
- (done) let variable declaration hide a type of same name
- (speculative) modify trans_declaration: flag indicating that the declaration in c-code is to be prepended
- (speculative) preprend flagged declarations to the beginning of the current block
- (speculative) allow (prepended) declaration after opening a bracket
- add variadic function

Keywords (for syntax highlight)

group stamp stump hidden private func name signature body aware feature extending verbatim
mutable plain retrievable forward embed cast foreach in verbatim_C keep fork try deduce scope
scope_local scope_func

